---
title: "NoteSmith - Agentic AI using LangGraph: Resume Chat Feature"
layout: default
nav_order: 13
parent: "Lecture Notes"
description: "Lecture notes: NoteSmith - Agentic AI using LangGraph: Resume Chat Feature"
last_modified_date: 2026-01-18
source_transcript: "014_How to build a Resume Chat feature like ChatGPT_ _ CampusX"
generated_by: "NoteSmith"
---

# NoteSmith - Agentic AI using LangGraph: Resume Chat Feature

---

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [Understanding the Resume Chat Feature](#understanding-the-resume-chat-feature)
4. [Architecture Overview](#architecture-overview)
5. [Implementation Roadmap](#implementation-roadmap)
6. [Step-by-Step Implementation](#step-by-step-implementation)
   - [Task Set 1: Building the Sidebar UI](#task-set-1-building-the-sidebar-ui)
   - [Task Set 2: Dynamic Thread ID Generation](#task-set-2-dynamic-thread-id-generation)
   - [Task Set 3: Managing Thread IDs](#task-set-3-managing-thread-ids)
   - [Task Set 4: Loading Previous Conversations](#task-set-4-loading-previous-conversations)
7. [Complete Code Walkthrough](#complete-code-walkthrough)
8. [Quick Reference](#quick-reference)
9. [Summary Table](#summary-table)
10. [Key Takeaways](#key-takeaways)
11. [Edge Cases & Common Mistakes](#edge-cases--common-mistakes)
12. [Interview Questions](#interview-questions)

---

## Overview

### What This Covers

This tutorial demonstrates how to implement a **Resume Chat** feature in a LangGraph-powered chatbot, similar to ChatGPT's conversation management system. You'll learn to:

- Create multiple conversation threads
- Switch between different conversations seamlessly
- Maintain conversation history across sessions
- Build an intuitive UI with Streamlit
- Manage state using session management

### Prerequisites

- Basic Python knowledge
- Understanding of Streamlit basics
- Familiarity with LangGraph chatbot architecture (covered in previous videos)
- Existing chatbot with streaming feature implemented

### Why It Matters

**Real-world applications:**
- **Multi-topic conversations**: Users can discuss different topics without losing context
- **Better UX**: Similar to professional chatbot interfaces (ChatGPT, Claude)
- **Session management**: Foundation for building production-ready chat applications
- **State persistence**: Critical for enterprise chatbot solutions

**Industry relevance:**
- Customer support systems need conversation history
- Educational platforms require topic-based chat separation
- Healthcare chatbots must maintain patient conversation threads
- Enterprise tools need audit trails of conversations

---

## Understanding the Resume Chat Feature

### What is Resume Chat?

> **Resume Chat** allows users to pause a conversation, start a new one on a different topic, and return to any previous conversation later while maintaining full context and history.

### Key Components

1. **Thread ID**: Unique identifier for each conversation
2. **Session State**: Temporary storage for current session data
3. **Message History**: List of all messages in a conversation
4. **Sidebar UI**: Interface for managing conversations
5. **Chat Threads List**: Collection of all conversation IDs

### How It Works

```
User Opens Chatbot
       ↓
Generates Thread ID (UUID)
       ↓
Stores in Session State
       ↓
User Chats → Messages stored with Thread ID
       ↓
User Clicks "New Chat"
       ↓
New Thread ID Generated
       ↓
Previous Thread ID saved to list
       ↓
User can click any Thread ID
       ↓
Load messages for that Thread
       ↓
Display in main chat area
```

---

## Architecture Overview

### Frontend (Streamlit)
- **Main Chat Area**: Displays current conversation
- **Sidebar**: Shows all conversation threads
- **New Chat Button**: Creates new conversation
- **Thread Buttons**: Clickable buttons to resume conversations

### Backend (LangGraph)
- **Thread Management**: Handles conversation separation
- **State Management**: Stores messages per thread
- **Message Retrieval**: Fetches conversation history

### Data Flow

```
┌─────────────────────────────────────────────────┐
│                  Streamlit UI                   │
│  ┌──────────────┐         ┌─────────────────┐  │
│  │   Sidebar    │         │   Main Chat     │  │
│  │              │         │                 │  │
│  │ New Chat Btn │         │  Message Area   │  │
│  │ Thread List  │         │                 │  │
│  └──────────────┘         └─────────────────┘  │
└─────────────────────────────────────────────────┘
                    ↕
┌─────────────────────────────────────────────────┐
│              Session State                      │
│  • current_thread_id                            │
│  • message_history (current conversation)       │
│  • chat_threads (list of all thread IDs)        │
└─────────────────────────────────────────────────┘
                    ↕
┌─────────────────────────────────────────────────┐
│              LangGraph Backend                  │
│  • Stores messages per thread_id                │
│  • Retrieves conversation history               │
│  • Manages checkpointing                        │
└─────────────────────────────────────────────────┘
```

---

## Implementation Roadmap

Breaking down the feature into manageable tasks:

### Task Set 1: UI Foundation
1. ✅ Add sidebar with title
2. ✅ Add "New Chat" button
3. ✅ Add "My Conversations" section
4. ✅ Display current thread ID

### Task Set 2: Dynamic Thread Management
1. ✅ Generate dynamic thread IDs using UUID
2. ✅ Store thread ID in session state
3. ✅ Replace hardcoded thread IDs

### Task Set 3: Thread Persistence
1. ✅ Create list to store all thread IDs
2. ✅ Add new threads to the list
3. ✅ Display all threads as clickable buttons
4. ✅ Prevent thread loss on new chat creation

### Task Set 4: Conversation Loading
1. ✅ Extract thread ID on button click
2. ✅ Fetch messages from LangGraph
3. ✅ Convert message format
4. ✅ Display in main chat area

---

## Step-by-Step Implementation

### Task Set 1: Building the Sidebar UI

#### Objective
Create a sidebar with:
- Title: "LangGraph ChatBot"
- Button: "New Chat"
- Header: "My Conversations"

#### Code Implementation

```python
import streamlit as st

# ============================================
# SIDEBAR UI
# ============================================

# Add title to sidebar
st.sidebar.title("LangGraph ChatBot")

# Add New Chat button
if st.sidebar.button("New Chat"):
    pass  # Functionality will be added later

# Add section header for conversations
st.sidebar.header("My Conversations")
```

#### Explanation

**Line-by-line breakdown:**

1. `st.sidebar.title("LangGraph ChatBot")`:
   - `st.sidebar` - Streamlit's sidebar container
   - `.title()` - Creates large heading text
   - Displays app name prominently

2. `st.sidebar.button("New Chat")`:
   - Creates clickable button in sidebar
   - Returns `True` when clicked, `False` otherwise
   - Used with `if` statement to trigger actions

3. `st.sidebar.header("My Conversations")`:
   - `.header()` - Creates medium-sized heading
   - Separates conversation list section

#### Testing

Run the application:
```bash
streamlit run frontend_threading.py
```

**Expected output:**
- Sidebar appears on left
- Title at top
- Button below title
- Header for conversations section

---

### Task Set 2: Dynamic Thread ID Generation

#### Why Dynamic Thread IDs?

**Problem with hardcoded IDs:**
```python
# ❌ Bad approach - hardcoded
thread_id = "thread_1"
```

- Users can create unlimited conversations
- Can't predict how many threads needed
- Manual management becomes impossible

**Solution - Dynamic generation:**
```python
# ✅ Good approach - dynamic
import uuid
thread_id = str(uuid.uuid4())
```

#### Understanding UUID

> **UUID (Universally Unique Identifier)** is a 128-bit number used to uniquely identify information. The probability of collision is extremely low.

**UUID4 format:**
```
550e8400-e29b-41d4-a716-446655440000
```

**Why UUID4?**
- Random generation (not based on time/MAC address)
- Cryptographically secure
- No central coordination needed
- Collision probability: 1 in 2^122

#### Implementation

**Step 1: Create Utility Function**

```python
import uuid

# ============================================
# UTILITY FUNCTIONS
# ============================================

def generate_thread_id():
    """
    Generates a unique thread ID using UUID4.
    
    Returns:
        str: A unique thread identifier
    
    Example:
        >>> thread_id = generate_thread_id()
        >>> print(thread_id)
        '550e8400-e29b-41d4-a716-446655440000'
    """
    thread_id = uuid.uuid4()  # Generate UUID object
    return str(thread_id)      # Convert to string
```

**Why convert to string?**
- Streamlit session state works better with strings
- Easier to display in UI
- Compatible with LangGraph's config format

**Step 2: Initialize Thread ID in Session**

```python
# ============================================
# SESSION SETUP
# ============================================

# Initialize message history if not exists
if "messages" not in st.session_state:
    st.session_state.messages = []

# Initialize thread ID if not exists
if "thread_id" not in st.session_state:
    st.session_state.thread_id = generate_thread_id()
```

**How session state works:**

```python
# First time page loads
st.session_state.thread_id  # Doesn't exist
↓
generate_thread_id() called
↓
st.session_state.thread_id = "550e8400-..."
↓
# Subsequent interactions
st.session_state.thread_id  # Already exists, not regenerated
```

**Step 3: Use Dynamic Thread ID**

```python
# ============================================
# CHATBOT INTERACTION
# ============================================

# Old approach (hardcoded)
# config = {"configurable": {"thread_id": "thread_1"}}

# New approach (dynamic)
config = {
    "configurable": {
        "thread_id": st.session_state.thread_id
    }
}

# Use in chatbot streaming
for chunk in chatbot.stream(
    {"messages": [{"role": "user", "content": user_input}]},
    config=config
):
    # Process streaming response
    pass
```

#### Complete Code for Task Set 2

```python
import streamlit as st
import uuid
from langchain_core.messages import HumanMessage, AIMessage

# ============================================
# UTILITY FUNCTIONS
# ============================================

def generate_thread_id():
    """Generate unique thread ID"""
    return str(uuid.uuid4())

# ============================================
# SESSION SETUP
# ============================================

# Initialize message history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Initialize thread ID dynamically
if "thread_id" not in st.session_state:
    st.session_state.thread_id = generate_thread_id()

# ============================================
# SIDEBAR UI
# ============================================

st.sidebar.title("LangGraph ChatBot")

if st.sidebar.button("New Chat"):
    pass  # Will implement later

st.sidebar.header("My Conversations")

# Display current thread ID
st.sidebar.text(st.session_state.thread_id)

# ============================================
# MAIN CHAT AREA
# ============================================

st.title("ChatBot")

# Display message history
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Chat input
if user_input := st.chat_input("Type your message..."):
    # Add user message to history
    st.session_state.messages.append({
        "role": "user",
        "content": user_input
    })
    
    # Display user message
    with st.chat_message("user"):
        st.markdown(user_input)
    
    # Get AI response
    config = {
        "configurable": {
            "thread_id": st.session_state.thread_id
        }
    }
    
    # Stream response from chatbot
    with st.chat_message("assistant"):
        response_placeholder = st.empty()
        full_response = ""
        
        for chunk in chatbot.stream(
            {"messages": [{"role": "user", "content": user_input}]},
            config=config
        ):
            if "messages" in chunk:
                content = chunk["messages"][0].content
                full_response += content
                response_placeholder.markdown(full_response)
        
        # Add AI response to history
        st.session_state.messages.append({
            "role": "assistant",
            "content": full_response
        })
```

#### Testing Task Set 2

**Test scenario:**
1. Load the chatbot
2. Check sidebar - you should see a UUID thread ID
3. Send a message
4. Refresh the page
5. Thread ID changes (new session)

---

### Task Set 3: Managing Thread IDs

#### The Problem

When user clicks "New Chat":
- ❌ Old thread ID disappears
- ❌ Can't access previous conversation
- ❌ Thread ID is lost forever

**Why this happens:**
```python
# When New Chat is clicked
st.session_state.thread_id = generate_thread_id()
# Old thread_id is overwritten and lost!
```

#### The Solution

**Strategy:**
1. Create a **list** to store all thread IDs
2. Store this list in session state (persists across interactions)
3. Add current thread ID to list before creating new one
4. Display all thread IDs from the list

**Visual representation:**

```
Session State Structure:
{
    "thread_id": "current-uuid-123",  ← Current conversation
    "chat_threads": [                  ← All conversations
        "uuid-001",
        "uuid-002", 
        "current-uuid-123"
    ],
    "messages": [...]
}
```

#### Implementation

**Step 1: Initialize Chat Threads List**

```python
# ============================================
# SESSION SETUP
# ============================================

# Initialize message history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Initialize thread ID
if "thread_id" not in st.session_state:
    st.session_state.thread_id = generate_thread_id()

# Initialize chat threads list (NEW)
if "chat_threads" not in st.session_state:
    st.session_state.chat_threads = []
```

**Step 2: Create Add Thread Utility Function**

```python
def add_thread(thread_id):
    """
    Adds a thread ID to the chat_threads list if not already present.
    
    Args:
        thread_id (str): The thread ID to add
    
    Purpose:
        - Prevents duplicate thread IDs
        - Maintains list of all conversations
        - Enables conversation history tracking
    
    Example:
        >>> add_thread("uuid-123")
        >>> st.session_state.chat_threads
        ['uuid-123']
        
        >>> add_thread("uuid-123")  # Duplicate
        >>> st.session_state.chat_threads
        ['uuid-123']  # Not added again
    """
    # Check if thread ID already exists in list
    if thread_id not in st.session_state.chat_threads:
        # Add to list only if new
        st.session_state.chat_threads.append(thread_id)
```

**Why check for duplicates?**
- Prevents same conversation appearing multiple times
- Keeps UI clean
- Reduces memory usage

**Step 3: Add Current Thread on Page Load**

```python
# ============================================
# SESSION SETUP
# ============================================

# ... previous initialization code ...

# Add current thread to list
add_thread(st.session_state.thread_id)
```

**When this runs:**
- First page load: Creates thread ID, adds to list
- Subsequent interactions: Thread already in list, not added again

**Step 4: Create Reset Chat Function**

```python
def reset_chat():
    """
    Resets the chat for a new conversation.
    
    Actions performed:
        1