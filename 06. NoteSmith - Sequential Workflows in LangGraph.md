---
title: "NoteSmith - Sequential Workflows in LangGraph"
layout: default
nav_order: 5
parent: "Lecture Notes"
description: "Lecture notes: NoteSmith - Sequential Workflows in LangGraph"
last_modified_date: 2026-01-18
source_transcript: "006_Sequential Workflows in LangGraph _ Agentic AI using LangGraph _ Video 5 _ CampusX"
generated_by: "NoteSmith"
---

# NoteSmith - Sequential Workflows in LangGraph

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites & Setup](#prerequisites--setup)
3. [Core Concepts Review](#core-concepts-review)
4. [Installation & Environment Setup](#installation--environment-setup)
5. [Building Your First Workflow - BMI Calculator](#building-your-first-workflow---bmi-calculator)
6. [Adding Complexity - BMI with Categorization](#adding-complexity---bmi-with-categorization)
7. [Simple LLM Workflow](#simple-llm-workflow)
8. [Prompt Chaining Workflow - Blog Generator](#prompt-chaining-workflow---blog-generator)
9. [Quick Reference](#quick-reference)
10. [Summary Table](#summary-table)
11. [Key Takeaways](#key-takeaways)
12. [Common Mistakes & Edge Cases](#common-mistakes--edge-cases)
13. [Interview Questions](#interview-questions)

---

## Overview

### ðŸ“š What This Covers

This lecture transitions from theoretical understanding of LangGraph to **practical implementation**. You'll learn to build **sequential workflows** - linear execution paths where tasks execute one after another without branching or parallel paths.

### ðŸŽ¯ Learning Objectives

1. Write basic LangGraph code from scratch
2. Build any sequential workflow independently
3. Understand the integration between LangChain and LangGraph
4. Visualize and debug workflows in Jupyter notebooks

### âœ… Prerequisites

- Understanding of Agentic AI vs Generative AI
- Knowledge of LangGraph core concepts (State, Nodes, Edges)
- Basic Python programming
- Familiarity with LLMs and OpenAI API

### ðŸ’¡ Why This Matters

Sequential workflows form the foundation of complex agentic systems. While they may seem like overkill for simple tasks, mastering these patterns prepares you for building sophisticated multi-agent systems, conditional routing, and parallel processing workflows.

---

## Prerequisites & Setup

### ðŸ”§ Required Knowledge

**From Previous Videos:**
- Difference between Generative AI and Agentic AI
- What is Agentic AI and its use cases
- Why LangGraph exists when LangChain is available
- Core LangGraph concepts: State, Nodes, Edges, Graphs

**Technical Skills:**
- Python basics
- Virtual environments
- Jupyter notebooks
- API key management

---

## Core Concepts Review

### ðŸ”„ What is a Sequential Workflow?

> **Sequential Workflow**: A workflow where all tasks are connected in a linear fashion. Task 1 â†’ Task 2 â†’ Task 3, with no branching or parallel paths.

**Characteristics:**
- Single execution path
- No conditional logic
- No parallel processing
- Predictable flow

**When to Use:**
- Simple data transformations
- Step-by-step processing
- Learning LangGraph basics
- Prototyping complex workflows

---

## Installation & Environment Setup

### ðŸ“¦ Step 1: Create Project Structure

```bash
# Create project folder
mkdir langgraph_tutorials
cd langgraph_tutorials

# Open in VS Code
code .
```

### ðŸ Step 2: Create Virtual Environment

```bash
# Create virtual environment
python -m venv myenv

# Activate (Windows)
myenv\Scripts\activate

# Activate (Mac/Linux)
source myenv/bin/activate
```

**Why Virtual Environments?**
- Isolate project dependencies
- Avoid version conflicts
- Reproducible environments
- Easy cleanup

### ðŸ“š Step 3: Install Required Libraries

```bash
# Install LangGraph
pip install langgraph

# Install LangChain (for LLM components)
pip install langchain

# Install OpenAI integration
pip install langchain-openai

# Install environment variable manager
pip install python-dotenv
```

**Library Breakdown:**

| Library | Purpose | Why Needed |
|---------|---------|------------|
| `langgraph` | Build workflow graphs | Core framework |
| `langchain` | LLM components | Chat models, prompts, loaders |
| `langchain-openai` | OpenAI models | Access GPT models |
| `python-dotenv` | Environment variables | Secure API key management |

### âœ… Step 4: Test Installation

Create `00_test_installation.ipynb`:

```python
# Test LangGraph import
from langgraph.graph import StateGraph

# Test LangChain import
from langchain_openai import ChatOpenAI

# Test typing
from typing import TypedDict

print("âœ… All imports successful!")
```

**Troubleshooting:**
- If imports fail, verify virtual environment is activated
- Check Python version (3.8+ required)
- Reinstall packages if needed

### ðŸ”‘ Step 5: Setup API Keys

Create `.env` file in project root:

```bash
OPENAI_API_KEY=sk-your-actual-api-key-here
```

**Security Best Practices:**
- Never commit `.env` to version control
- Add `.env` to `.gitignore`
- Use different keys for dev/prod
- Rotate keys regularly

---

## Building Your First Workflow - BMI Calculator

### ðŸŽ¯ Workflow Overview

**Goal**: Calculate BMI from weight and height

**Flow Diagram:**
```
START â†’ Calculate_BMI â†’ END
```

**State Structure:**
- `weight_kg`: float (input)
- `height_m`: float (input)
- `bmi`: float (output)

### ðŸ“ Step-by-Step Implementation

#### Step 1: Define State

```python
from typing import TypedDict

class BMIState(TypedDict):
    """
    State for BMI calculation workflow.
    
    TypedDict allows us to specify data types for each key,
    providing type hints and better IDE support.
    """
    weight_kg: float    # Weight in kilograms
    height_m: float     # Height in meters
    bmi: float          # Calculated BMI value
```

**Why TypedDict?**
- Type safety at development time
- Better autocomplete in IDEs
- Self-documenting code
- Catches type errors early

**State Design Principles:**
1. Include all data that flows through workflow
2. Use descriptive names with units
3. Specify correct data types
4. Keep it minimal - only essential data

#### Step 2: Define Node Function

```python
def calculate_bmi(state: BMIState) -> BMIState:
    """
    Node function to calculate BMI.
    
    Args:
        state: Current state containing weight and height
        
    Returns:
        Updated state with calculated BMI
        
    Formula: BMI = weight (kg) / height (m)Â²
    """
    # Extract values from state
    weight = state["weight_kg"]
    height = state["height_m"]
    
    # Calculate BMI using standard formula
    bmi_value = weight / (height ** 2)
    
    # Update state with calculated value (partial update)
    state["bmi"] = round(bmi_value, 2)
    
    # Return updated state
    return state
```

**Line-by-Line Breakdown:**

1. **Function Signature**: 
   - Takes `BMIState` as input
   - Returns `BMIState` as output
   - Type hints enable IDE support

2. **Extract Values**:
   - Access state like a dictionary
   - State contains all workflow data

3. **Calculate BMI**:
   - Standard BMI formula
   - `**` is Python's exponentiation operator

4. **Update State**:
   - Partial update - only modify `bmi` key
   - `round()` limits to 2 decimal places
   - State is mutable

5. **Return State**:
   - Always return state from nodes
   - Next node receives this updated state

**Node Function Rules:**
- Always accept state as input
- Always return state as output
- Perform partial state updates
- Keep logic focused and simple

#### Step 3: Create Graph Object

```python
from langgraph.graph import StateGraph

# Create graph instance with state type
graph = StateGraph(BMIState)
```

**What This Does:**
- Initializes empty graph structure
- Registers state type for validation
- Prepares graph for node/edge addition

#### Step 4: Add Nodes

```python
# Add node to graph
graph.add_node(
    "calculate_bmi",      # Node name (identifier)
    calculate_bmi         # Function to execute
)
```

**Parameters Explained:**
- **First argument**: Node name (string identifier)
- **Second argument**: Python function reference (no parentheses!)

**Common Mistake:**
```python
# âŒ Wrong - calling function
graph.add_node("calculate_bmi", calculate_bmi())

# âœ… Correct - passing function reference
graph.add_node("calculate_bmi", calculate_bmi)
```

#### Step 5: Add Edges

```python
from langgraph.graph import START, END

# Connect START to our node
graph.add_edge(START, "calculate_bmi")

# Connect our node to END
graph.add_edge("calculate_bmi", END)
```

**Edge Types:**
- **START**: Special node marking workflow entry
- **END**: Special node marking workflow exit
- **Custom nodes**: Your defined nodes

**Edge Syntax:**
```python
graph.add_edge(source, target)
```

**Flow Visualization:**
```
START â†’ calculate_bmi â†’ END
```

#### Step 6: Compile Graph

```python
# Compile graph into executable workflow
workflow = graph.compile()
```

**What Compilation Does:**
1. Validates graph structure
2. Checks for disconnected nodes
3. Verifies state consistency
4. Creates executable runnable
5. Optimizes execution path

**Compilation Errors:**
- Disconnected nodes
- Missing START/END connections
- Invalid state types
- Circular dependencies

#### Step 7: Execute Workflow

```python
# Define initial state
initial_state = {
    "weight_kg": 80,
    "height_m": 1.73
}

# Execute workflow
final_state = workflow.invoke(initial_state)

# Print result
print(final_state)
# Output: {'weight_kg': 80, 'height_m': 1.73, 'bmi': 26.73}
```

**Execution Flow:**
1. Initial state provided to workflow
2. START node receives state
3. State flows to `calculate_bmi`
4. Node executes, updates state
5. State flows to END
6. Final state returned

**Key Points:**
- Input: Dictionary matching state structure
- Output: Complete state with all updates
- State persists throughout workflow
- All intermediate values accessible

### ðŸ“Š Visualizing the Graph

```python
from IPython.display import Image, display

# Visualize graph structure
display(Image(workflow.get_graph().draw_mermaid_png()))
```

**Why Jupyter Notebooks?**
- Built-in visualization support
- Interactive execution
- Easy debugging
- Step-by-step testing

**Visualization Benefits:**
- Verify graph structure
- Debug flow issues
- Document workflows
- Share with team

### ðŸ” Complete Code

```python
# File: bmi_workflow.ipynb

# ============= IMPORTS =============
from langgraph.graph import StateGraph, START, END
from typing import TypedDict

# ============= STATE DEFINITION =============
class BMIState(TypedDict):
    """State containing BMI calculation data"""
    weight_kg: float
    height_m: float
    bmi: float

# ============= NODE FUNCTIONS =============
def calculate_bmi(state: BMIState) -> BMIState:
    """Calculate BMI from weight and height"""
    weight = state["weight_kg"]
    height = state["height_m"]
    
    bmi_value = weight / (height ** 2)
    state["bmi"] = round(bmi_value, 2)
    
    return state

# ============= GRAPH CONSTRUCTION =============
# Create graph
graph = StateGraph(BMIState)

# Add nodes
graph.add_node("calculate_bmi", calculate_bmi)

# Add edges
graph.add_edge(START, "calculate_bmi")
graph.add_edge("calculate_bmi", END)

# Compile
workflow = graph.compile()

# ============= EXECUTION =============
initial_state = {
    "weight_kg": 80,
    "height_m": 1.73
}

final_state = workflow.invoke(initial_state)
print(f"BMI: {final_state['bmi']}")
```

---

## Adding Complexity - BMI with Categorization

### ðŸŽ¯ Enhanced Workflow

**New Requirement**: Categorize BMI as Underweight, Normal, Overweight, or Obese

**Updated Flow:**
```
START â†’ Calculate_BMI â†’ Label_BMI â†’ END
```

**Updated State:**
```python
class BMIState(TypedDict):
    weight_kg: float
    height_m: float
    bmi: float
    category: str  # NEW: BMI category
```

### ðŸ“ Implementation Changes

#### Step 1: Update State

```python
class BMIState(TypedDict):
    weight_kg: float
    height_m: float
    bmi: float
    category: str  # Added category field
```

**Why Update State?**
- New data needs storage
- State must include all workflow data
- Enables access in later nodes

#### Step 2: Add New Node Function

```python
def label_bmi(state: BMIState) -> BMIState:
    """
    Categorize BMI value into health categories.
    
    Categories based on WHO standards:
    - Underweight: BMI < 18.5
    - Normal: 18.5 â‰¤ BMI < 25
    - Overweight: 25 â‰¤ BMI < 30
    - Obese: BMI â‰¥ 30
    """
    bmi = state["bmi"]
    
    # Categorization logic
    if bmi < 18.5:
        state["category"] = "Underweight"
    elif 18.5 <= bmi < 25:
        state["category"] = "Normal"
    elif 25 <= bmi < 30:
        state["category"] = "Overweight"
    else:
        state["category"] = "Obese"
    
    return state
```

**Decision Logic:**
- Uses standard WHO BMI categories
- Conditional branching within node
- Updates state with category
- Returns modified state

#### Step 3: Update Graph

```python
# Add new node
graph.add_node("label_bmi", label_bmi)

# Update edges
graph.add_edge(START, "calculate_bmi")
graph.add_edge("calculate_bmi", "label_bmi")  # NEW
graph.add_edge("label_bmi", END)              # UPDATED
```

**Edge Changes:**
- `calculate_bmi` now points to `label_bmi`
- `label_bmi` points to END
- Creates sequential chain

#### Step 4: Execute Enhanced Workflow

```python
initial_state = {
    "weight_kg": 80,
    "height_m": 1.73
}

final_state = workflow.invoke(initial_state)
print(final_state)
# Output: {
#     'weight_kg': 80, 
#     'height_m': 1.73, 
#     'bmi': 26.73,
#     'category': 'Overweight'
# }
```

### ðŸ”„ State Evolution

**State at Each Step:**

```
Initial State:
{
    "weight_kg": 80,
    "height_m": 1.73
}

After calculate_bmi:
{
    "weight_kg": 80,
    "height_m": 1.73,
    "bmi": 26.73
}

After label_bmi (Final):
{
    "weight_kg": 80,
    "height_m": 1.73,
    "bmi": 26.73,
    "category": "Overweight"
}
```

**Key Insight**: State accumulates data as it flows through nodes. Nothing is lost.

---

## Simple LLM Workflow

### ðŸŽ¯ Workflow Overview

**Goal**: Ask a question to an LLM and get an answer

**Flow:**
```
START â†’ LLM_QA â†’ END
```

**State:**
```python
class LLMState(TypedDict):
    question: str  # Input question
    answer: str    # LLM response
```

### ðŸ“ Implementation

#### Step 1