---
title: "Complete Lecture Notes: Agentic AI using LangGraph"
layout: default
nav_order: 3
parent: "Lecture Notes"
description: "Lecture notes: Complete Lecture Notes: Agentic AI using LangGraph"
last_modified_date: 2026-01-18
source_transcript: "004_LangChain Vs LangGraph _ Agentic AI using LangGraph _ Video 3 _ CampusX"
generated_by: "NoteSmith"
---

# Complete Lecture Notes: Agentic AI using LangGraph

## Course Overview

### Video Context & Prerequisites
This is **Part 3** of the Agentic AI using LangGraph playlist, building upon:
- **Video 1**: Differences between Agentic AI and Generative AI
- **Video 2**: Detailed overview of Agentic AI with automated hiring example

**Essential Prerequisites:**
- Understanding of LangChain fundamentals
- Basic LangChain coding experience
- Recommended: First 2 videos of LangChain playlist (Introduction and Components)

### Learning Objectives
1. Develop **deep intuition** on why LangGraph exists
2. Gain **technical overview** of what LangGraph is
3. Understand **comparison** between LangChain and LangGraph
4. Learn to **decide when to use** LangChain vs LangGraph for applications

---

## Part 1: Understanding LangChain

### What is LangChain?

**Definition**: An open-source library designed to simplify the process of building LLM-based applications

**Core Problem It Solves:**
- Building LLM-based applications requires integrating multiple components
- LangChain provides **modular building blocks** to create any LLM-based workflow

### Key Components (Building Blocks)

#### 1. Model Component
- Provides **unified interface** to interact with any LLM provider
- Supports multiple providers:
  - OpenAI models
  - Anthropic's Claude
  - HuggingFace models
  - Ollama
- **Benefit**: Easy switching between models with minimal code changes

#### 2. Prompts Component
- Helps engineer prompts in various ways
- Manages the prompt design process
- Critical for effective LLM interaction

#### 3. Retrievers Component
- Fetches relevant documents from vector stores or knowledge bases
- Offers different strategies and algorithms
- Essential for building RAG-based applications

#### 4. Chains Component ⭐ (Most Important)
- **Core offering** of LangChain (hence the name)
- Connects different components together
- **Automatic data flow**: Output of one block becomes input of next
- Can create chains of any length
- Enables sequential processing

### What You Can Build with LangChain

#### 1. Simple Conversational Workflows
- Chatbots
- Text summarizers
- **Flow**: User prompt → LLM → Output to user
- Can implement in loops for continuous chat

#### 2. Multi-step Workflows
- **Example**: Topic → Detailed Report → Summary
- **Chain structure**: Prompt → LLM → Prompt → LLM → Output Parser
- Sequential processing of multiple tasks

#### 3. RAG-based Applications
- **Flow**: User prompt → Retriever → Fetch context from vector store → Context + Prompt → LLM → Response
- Enables chatting with documents

#### 4. Simple Level Agents
- **Tools concept**: Connect LLMs with APIs or Python functions
- LLM decides when to call which tool with what input
- **Example**: Weather API tool
  - User asks about weather
  - LLM triggers weather API
  - Returns formatted response

---

## Part 2: The Complex Workflow Challenge

### Case Study: Automated Hiring Workflow

#### Important Distinction: Workflow vs Agentic AI

**Key Difference** (from Anthropic's blog):
- **Workflows**: Systems where LLMs and tools are orchestrated through **predefined code paths**
- **Agents**: Systems where LLMs **dynamically direct** their own processes and tool usage

> ⚠️ **Note**: This automated hiring example is a **WORKFLOW**, not an Agentic AI application
> - Flow chart is pre-built by developer
> - Executes in same order every time
> - **Static** (not dynamic like true agents)

### Detailed Workflow Breakdown

#### Phase 1: Job Description Creation
1. **Start**: Receive hiring request
   - *Example*: "Need to hire backend engineer, remote, 2-4 years experience"
2. **Create JD**: LLM generates job description based on request
3. **Check Approval**: Human supervisor reviews JD
   - ❌ Not approved → Loop back to Create JD
   - ✅ Approved → Continue

#### Phase 2: Job Posting & Monitoring
4. **Post JD**: Use tools (LinkedIn API, Naukri.com API) to post job
5. **Wait 7 Days**: Allow time for applications
6. **Monitor Applications**: Check number of applications received
7. **Decision Point**: Enough applications?
   - **No** → Modify JD (reduce requirements, increase salary, etc.)
     - Wait 48 hours
     - Monitor again
     - Loop until threshold met
   - **Yes** (e.g., 25 applications when threshold is 20) → Continue

#### Phase 3: Candidate Selection
8. **Study Resumes**: Parse and score all resumes using LLM
9. **Shortlist**: Select top candidates (e.g., 5 candidates)
10. **Schedule Interviews**: 
    - Use Calendar API to check availability
    - Send emails via Mail API

#### Phase 4: Interview Process
11. **Conduct Interview**: 
    - Provide question bank
    - Send reminder emails
    - Conduct interviews
12. **For Each Candidate**:
    - ❌ Not Selected → Send regret email
    - ✅ Selected → Send offer letter

#### Phase 5: Offer & Onboarding
13. **Send Offer Letter**: 
    - LLM creates offer letter
    - Send via Mail API
14. **Track Acceptance**:
    - ❌ Not Accepted → Renegotiate → Send new offer
    - ✅ Accepted → Start onboarding
15. **Onboarding**:
    - Integration with HRMS
    - Send welcome email
    - Plan KT sessions
    - Provision laptop
16. **End Process**

### Workflow Characteristics
- ✅ **Multiple loops**: JD approval, application monitoring, offer acceptance
- ✅ **Conditional branches**: Based on approvals, application counts, selections
- ✅ **Jumps**: Moving back to previous steps
- ✅ **Long-running**: Can take days to months
- ✅ **Event-driven**: Waits for external triggers (time, human input)

---

## Part 3: Six Key Challenges & LangGraph Solutions

### Challenge #1: Control Flow Complexity

#### The Problem with LangChain

**LangChain is designed for LINEAR workflows**
- Works well with chains (sequential execution)
- The automated hiring workflow is **HIGHLY NON-LINEAR**

**Three Sources of Non-Linearity:**

1. **Conditional Branches**
   - Based on conditions, flow goes in different directions
   - *Example*: Enough applications? → Yes/No paths

2. **Loops**
   - Repeating steps until condition met
   - *Example*: Keep creating JD until approved
   - *Example*: Keep modifying JD until enough applications

3. **Jumps**
   - Control flow suddenly moves to different location
   - *Example*: After 48-hour wait, jump back to monitor applications

#### LangChain Implementation Attempt

```python
# Hiring request
hiring_prompt = "Need to hire software engineer for backend team"

# Create LLM and prompt template
llm = ChatOpenAI()
jd_prompt = PromptTemplate("Create job description based on: {hiring_request}")

# Chain for JD creation
jd_chain = jd_prompt | llm | StrOutputParser()

# Functions for approval and posting
def approve_jd(jd): # Dummy function
    pass

def post_jd(jd): # Dummy function
    pass

# PROBLEM: Need custom Python code for loop
approved = False
while not approved:
    jd = jd_chain.invoke({"hiring_request": hiring_prompt})
    approved = approve_jd(jd)

post_jd(jd)
```

#### The Glue Code Problem

**Issue**: 
- LangChain doesn't provide constructs for loops, conditionals, jumps
- Must write **custom Python code** (glue code) to handle control flow
- More glue code = harder to maintain, debug, and collaborate

**For complex workflows**:
- Multiple loops, conditionals, jumps needed
- Massive amounts of glue code required
- Maintainability becomes very difficult
- Team collaboration suffers

#### LangGraph Solution

**LangGraph provides native constructs for control flow:**
- Built-in support for loops, conditionals, and jumps
- No glue code needed
- Everything within the framework
- Better maintainability and collaboration

---

### Challenge #2: State Management

#### What is State?

**State** = Information that needs to be tracked and passed between different steps of the workflow

**Examples from Hiring Workflow:**
- Job description text
- Number of applications received
- List of shortlisted candidates
- Interview schedules
- Offer letter details

#### The Problem in LangChain

**Manual State Management Required:**
- Developer must manually pass state between chain components
- No built-in mechanism for state persistence
- Becomes complex with multiple variables
- Error-prone as workflow grows

**Example Issues:**
- How to pass JD from creation step to posting step?
- How to track application count across monitoring loops?
- How to maintain candidate list through multiple stages?

#### LangGraph Solution

**Built-in State Management:**
- **Centralized state object** accessible to all nodes
- Automatic state persistence
- State updates handled by framework
- **Checkpoint system**: Saves state after each step
- Can store state in memory or external database

**Benefits:**
- Simplified code
- Reduced errors
- Easier debugging
- Automatic state tracking

---

### Challenge #3: Fault Tolerance

#### The Problem in LangChain

- **No built-in fault tolerance** in LangChain
- If a 5-step chain fails at step 3, you must restart from the beginning
- LangChain assumes chains are **short-lived** (quick execution and completion)
- Not designed for long-running workflows

#### LangGraph's Solution

Provides fault tolerance for both small and large failures:

**Small-Level Faults (Retry Logic):**
- **Example**: LinkedIn API is down while posting a job
- Can implement retry logic to catch errors and try again after a delay
- Handles transient failures automatically

**System-Level Faults (Recovery):**
- **Scenario**: Server crashes, machine shuts down, Docker container fails
- **Recovery mechanism**: Resume from exact point of failure

**How It Works:**
1. Uses checkpoint system
2. Tracks and saves state continuously (in memory or external database)
3. Creates checkpoint after each node execution
4. Stores snapshot of state in memory
5. Can resume using `resume()` function with previous state
6. Automatically identifies failed node and next node to execute

**Key Advantage:**
- Designed for **long-running workflows** where faults are expected
- Built-in retry and recovery logic

---

### Challenge #4: Human-in-the-Loop

#### What is Human-in-the-Loop?

Workflow pauses at specific stages for human decision-making

**Examples:**
- Approving generated job description
- Confirming before posting to website
- Manager approval for scheduling interviews

**Importance:**
- Critical for **accountability** in risky operations
- Humans should control sensitive decisions, not just agents

#### LangChain Limitations

- **No default mechanism** for pausing and resuming chains
- Can request input, but only for **short durations**

**Problem with Long Waits** (e.g., 24-hour approval):
- Script remains running, consuming compute resources
- Risk of crashes during wait period
- Not designed for long-running workflows

**Workaround in LangChain:**
- Split chain into two parts at approval point
- Execute first chain → wait for approval → execute second chain
- **Issues**: Manual state transfer, glue code, maintainability problems

#### LangGraph's Solution

- **First-class citizen feature** - built into the framework from the start
- Can pause execution **indefinitely** (minutes, hours, or days)

**How It Works:**
1. Checkpoints graph state after every step
2. Persists execution context
3. Resumes workflow from where it left off
4. Supports **asynchronous human review** without time constraints

**Analogy:**
> Like playing a video game:
> - Save progress at Stage 3
> - Resume tomorrow from Stage 3, not from the beginning

---

### Challenge #5: Nested Workflows (Subgraphs)

#### What are Nested Workflows?

- A **subgraph** is a graph used as a node in another graph
- Allows building workflows within workflows
- Concept of **encapsulation** applied to LangGraph

**Visual Representation:**
```
Main Graph: Node1 → [Subgraph] → Node3
                      ↓
            Subgraph contains its own nodes and edges
```

#### Use Cases

**1. Multi-Agent Systems**

*Example: Self-Driving Car*
- Agent 1: Processes sensor information
- Agent 2: Handles driving capabilities
- Agent 3: Manages entertainment system
- Agent 4: CEO agent that coordinates all others

Multiple agents working together to solve complex problems

**2. Reusability**

Create reusable workflow components

*Example: Approval Workflow*
- Build once as a subgraph
- Reuse for:
  - JD approval
  - Posting approval
  - Interview scheduling approval
- Similar to creating reusable functions in programming

#### State Management Challenge

- Both parent graph and subgraph have their own states
- Need to understand how states communicate between nested workflows

#### LangChain Limitation

- Cannot implement nested workflows
- Already struggles with single workflows
- No support for workflow-within-workflow architecture

---

### Challenge #6: Observability

#### What is Observability?

**Definition**: How easily you can monitor, debug, and understand what your workflow is doing at runtime

#### Why It's Important

- **Production monitoring**: Track deployed agents/workflows
- **Debugging**: Identify errors and crashes
- **Auditing**: Understand decision-making process

**Example Scenario:**
> Agent posts unlimited LinkedIn ads, spending excessive money
> - Need to trace back what steps led to this decision

#### LangSmith Tool

Library for monitoring LLM-based applications that integrates with LangChain

**Records:**
- LLM calls made
- Prompts sent
- Responses received
- Token counts
- Response times

#### LangChain + LangSmith Limitation

- **Partial observability only**
- Tracks LangChain code but **not glue code**

**Problem:**
- ✅ Can track LLM calls
- ❌ Cannot understand loops or custom logic
- ❌ Cannot identify which loop iteration an LLM call belongs to
- Complex applications = incomplete observability

#### LangGraph + LangSmith Solution

**Tight integration** between LangGraph and LangSmith

**Complete observability** because:
- No glue code needed
- All code within LangGraph framework
- Tracks entire stateful execution

**What Gets Recorded:**
- Node-to-node transitions
- Timeline of events
- State before and after each node
- Messages exchanged between human and agent
- Human approval points and timing
- **Complete chronological timeline** from start to finish

**Advantage:**
- Full backtrace capability
- Easier debugging
- Complete audit trail

---

## Part 4: LangChain vs LangGraph - The Complete Picture

### Important Clarification

#### They Are NOT Replacements

**LangGraph is built on top of LangChain**
- LangGraph doesn't replace LangChain
- It solves more complex problems
- They work hand-in-hand

### What You Still Use from LangChain

When working with LangGraph, you continue using:
- ChatOpenAI
- Prompt Templates
- Retrievers
- Document Loaders
- Text Splitters
- Tools

### Division of Responsibilities

| LangChain | LangGraph |
|-----------|-----------|
| Provides components and building blocks | Orchestrates and chains workflows |
| Simple, linear chaining | Advanced workflow orchestration |
| Individual tools | Framework for complex control flow |

**Analogy:**
- **LangChain** = Components library + simple chaining
- **LangGraph** = Advanced workflow orchestration framework

---

## Decision Framework: When to Use What?

### Use LangChain For:

✅ **Simple, linear workflows**
- Prompt chains
- Summarizers
- Basic RAG systems
- Quick prototypes
- Straightforward sequential processing

### Use LangGraph For:

✅ **Complex, non-linear workflows**
- Conditional paths
- Loops
- Human-in-the-loop steps
- Multi-agent coordination/collaboration
- Asynchronous, event-driven execution
- Long-running processes
- Workflows requiring fault tolerance
- Applications needing complete observability

---

## Summary: Six Key Advantages of LangGraph

| Challenge | LangChain Limitation | LangGraph Solution |
|-----------|---------------------|-------------------|
| **1. Control Flow** | Requires glue code for loops, conditionals, jumps | Native constructs for complex control flow |
| **2. State Management** | Manual state passing | Built-in centralized state with checkpoints |
| **3. Fault Tolerance** | Must restart from beginning | Resume from exact failure point |
| **4. Human-in-the-Loop** | Limited to short waits | Indefinite pause/resume capability |
| **5. Nested Workflows** | Not supported | Subgraphs for multi-agent systems |
| **6. Observability** | Partial (misses glue code) | Complete timeline and state tracking |

---

## Key Takeaways

1. **LangChain knowledge is foundational** - it's not wasted; LangGraph builds on it
2. **LangGraph solves complexity** - designed for workflows that LangChain struggles with
3. **Complementary tools** - use both together for maximum effectiveness
4. **Choose based on complexity** - simple workflows → LangChain; complex workflows → LangGraph
5. **Built-in best practices** - LangGraph incorporates fault tolerance, observability, and state management from the start
6. **Production-ready** - LangGraph is designed for real-world, long-running applications

---

## Next Steps

To continue your learning journey:
1. Practice building simple workflows in LangChain
2. Identify which workflows would benefit from LangGraph features
3. Explore LangGraph documentation and examples
4. Experiment with converting a LangChain workflow to LangGraph
5. Learn about state management and checkpoint systems in depth

**Your LangChain knowledge is still valuable** - it's the foundation upon which LangGraph builds more sophisticated capabilities.