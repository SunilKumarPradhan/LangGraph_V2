---
title: "NoteSmith - Agentic AI Using LangGraph: Conditional Workflows"
layout: default
nav_order: 7
parent: "Lecture Notes"
description: "Lecture notes: NoteSmith - Agentic AI Using LangGraph: Conditional Workflows"
last_modified_date: 2026-01-18
source_transcript: "008_Conditional Workflows in LangGraph _ Agentic AI using LangGraph _ Video 7 _ CampusX"
generated_by: "NoteSmith"
---

# NoteSmith - Agentic AI Using LangGraph: Conditional Workflows

## Table of Contents

1. [Overview](#overview)
2. [Recap: Workflow Types Covered So Far](#recap-workflow-types-covered-so-far)
3. [What are Conditional Workflows?](#what-are-conditional-workflows)
4. [Conditional vs Parallel Workflows](#conditional-vs-parallel-workflows)
5. [Example 1: Quadratic Equation Solver (Non-LLM)](#example-1-quadratic-equation-solver-non-llm)
6. [Example 2: Customer Support Review System (LLM-Based)](#example-2-customer-support-review-system-llm-based)
7. [Quick Reference](#quick-reference)
8. [Summary Table](#summary-table)
9. [Key Takeaways](#key-takeaways)
10. [Edge Cases & Common Mistakes](#edge-cases--common-mistakes)
11. [Interview Questions](#interview-questions)

---

## Overview

### ğŸ¯ What This Covers
This lecture is the **7th video** in the "Agentic AI Using LangGraph" playlist. It focuses on building **conditional workflows** - a critical pattern for creating intelligent, decision-making AI agents.

### ğŸ“‹ Prerequisites
- Understanding of sequential workflows (linear task execution)
- Understanding of parallel workflows (simultaneous task execution)
- Basic Python programming
- Familiarity with if-else conditional logic
- LangGraph basics (State, StateGraph, nodes, edges)

### ğŸ’¡ Why It Matters
Conditional workflows are to LangGraph what **if-else statements are to programming** - absolutely essential. Almost every complex workflow you build will require conditional branching. This enables your AI agents to make intelligent decisions based on runtime conditions, just like humans do.

**Real-world applications:**
- Customer support routing (technical vs billing issues)
- Content moderation (approve/reject/review)
- Medical diagnosis systems (different treatment paths)
- E-commerce order processing (payment success/failure paths)
- Chatbot conversation flows (different responses based on user intent)

---

## Recap: Workflow Types Covered So Far

### 1ï¸âƒ£ Sequential Workflows
**Definition:** Tasks execute one after another in a linear fashion.

```
Task 1 â†’ Task 2 â†’ Task 3 â†’ Task 4
```

**Characteristics:**
- Simple, predictable flow
- Each task waits for the previous one to complete
- No branching or parallel execution

**Use case:** Data processing pipelines where each step depends on the previous output.

---

### 2ï¸âƒ£ Parallel Workflows
**Definition:** Multiple tasks execute simultaneously, then results merge.

```
        â”Œâ”€â†’ Task 2 â”€â”
Task 1 â”€â”¤           â”œâ”€â†’ Task 4
        â””â”€â†’ Task 3 â”€â”˜
```

**Characteristics:**
- Tasks 2 and 3 execute **at the same time**
- Both branches are always executed
- Results combine before moving to Task 4

**Use case:** Fetching data from multiple APIs simultaneously to reduce total execution time.

---

## What are Conditional Workflows?

### ğŸ”€ Definition
A **conditional workflow** is one where you have multiple possible paths (branches), but **only ONE path is executed** based on a condition - similar to if-else logic in programming.

### Visual Representation

```
                â”Œâ”€â†’ Task 2 â”€â”
Task 1 â”€(condition)â”€â”¤        â”œâ”€â†’ Task 4
                â””â”€â†’ Task 3 â”€â”˜
```

**Key difference from parallel workflows:**
- You go to **either** Task 2 **or** Task 3, never both
- The decision is made based on a condition
- Execution paths: `1â†’2â†’4` OR `1â†’3â†’4` (never `1â†’2â†’3â†’4`)

---

## Conditional vs Parallel Workflows

| Aspect | Parallel Workflow | Conditional Workflow |
|--------|------------------|---------------------|
| **Branch Execution** | ALL branches execute | ONLY ONE branch executes |
| **Decision Making** | No decision needed | Condition determines path |
| **Edge Type** | Solid edges | Dotted edges (in LangGraph visualization) |
| **Programming Analogy** | Running multiple threads | if-else statement |
| **Use Case** | Fetch data from 3 APIs simultaneously | Route customer to technical/billing support |
| **Execution Time** | Potentially faster (parallel) | Sequential (one path only) |

### ğŸ“Š Visual Comparison

**Parallel Workflow:**
```python
# Both functions execute
result_a = fetch_from_api_a()  # Runs simultaneously
result_b = fetch_from_api_b()  # Runs simultaneously
combined = merge(result_a, result_b)
```

**Conditional Workflow:**
```python
# Only one function executes
if condition:
    result = process_path_a()  # Either this
else:
    result = process_path_b()  # Or this, never both
```

---

## Example 1: Quadratic Equation Solver (Non-LLM)

### ğŸ“ Problem Statement
Build a workflow that solves quadratic equations of the form:

```
axÂ² + bx + c = 0
```

### Mathematical Background

#### What is a Quadratic Equation?
A quadratic equation is a polynomial equation of degree 2. The general form is:

> **axÂ² + bx + c = 0**
> 
> where a, b, c are coefficients and a â‰  0

#### The Discriminant
The **discriminant (D)** determines the nature of roots:

```
D = bÂ² - 4ac
```

#### Three Possible Conditions

| Condition | Result | Formula for Roots |
|-----------|--------|------------------|
| **D > 0** | Two distinct real roots | râ‚ = (-b + âˆšD) / 2a<br>râ‚‚ = (-b - âˆšD) / 2a |
| **D = 0** | One repeated root | r = -b / 2a |
| **D < 0** | No real roots | Complex roots (not calculated here) |

### ğŸ—ºï¸ Workflow Design

```
Input (a, b, c)
    â†“
Show Equation
    â†“
Calculate Discriminant
    â†“
  (Check D)
    â”œâ”€â†’ [D > 0] â†’ Calculate Two Real Roots â†’ End
    â”œâ”€â†’ [D = 0] â†’ Calculate Repeated Root â†’ End
    â””â”€â†’ [D < 0] â†’ No Real Roots â†’ End
```

### ğŸ’» Complete Implementation

```python
# Import necessary libraries
from langgraph.graph import StateGraph
from typing import TypedDict

# Step 1: Define the State
class QuadState(TypedDict):
    """
    State to store all information throughout the workflow.
    
    Attributes:
        a: Coefficient of xÂ²
        b: Coefficient of x
        c: Constant term
        equation: String representation of the equation
        discriminant: Value of bÂ² - 4ac
        result: Final result (roots or message)
    """
    a: float
    b: float
    c: float
    equation: str
    discriminant: float
    result: str

# Step 2: Define Node Functions

def show_equation(state: QuadState) -> dict:
    """
    Creates a string representation of the quadratic equation.
    
    Args:
        state: Current state containing a, b, c values
        
    Returns:
        Dictionary with equation string
        
    Example:
        Input: a=4, b=-5, c=-4
        Output: {"equation": "4xÂ² + -5x + -4"}
    """
    equation = f"{state['a']}xÂ² + {state['b']}x + {state['c']}"
    return {"equation": equation}

def calculate_discriminant(state: QuadState) -> dict:
    """
    Calculates the discriminant using the formula: bÂ² - 4ac
    
    Args:
        state: Current state containing a, b, c values
        
    Returns:
        Dictionary with discriminant value
        
    Mathematical explanation:
        - bÂ² gives us the square of the middle coefficient
        - 4ac is the product of 4, first coefficient, and constant
        - The difference determines the nature of roots
    """
    discriminant = (state['b'] ** 2) - (4 * state['a'] * state['c'])
    return {"discriminant": discriminant}

def real_roots(state: QuadState) -> dict:
    """
    Calculates two distinct real roots when D > 0.
    
    Formula:
        root1 = (-b + âˆšD) / 2a
        root2 = (-b - âˆšD) / 2a
    
    Args:
        state: Current state with discriminant > 0
        
    Returns:
        Dictionary with result string containing both roots
    """
    # Calculate first root: add square root of discriminant
    root1 = (-state['b'] + (state['discriminant'] ** 0.5)) / (2 * state['a'])
    
    # Calculate second root: subtract square root of discriminant
    root2 = (-state['b'] - (state['discriminant'] ** 0.5)) / (2 * state['a'])
    
    result = f"The roots are {root1} and {root2}"
    return {"result": result}

def repeated_roots(state: QuadState) -> dict:
    """
    Calculates the single repeated root when D = 0.
    
    Formula:
        root = -b / 2a
    
    Why only one root?
        When D = 0, both formulas give the same value because âˆš0 = 0
    
    Args:
        state: Current state with discriminant = 0
        
    Returns:
        Dictionary with result string containing the repeated root
    """
    root = -state['b'] / (2 * state['a'])
    result = f"Only repeating root is {root}"
    return {"result": result}

def no_real_roots(state: QuadState) -> dict:
    """
    Returns message when D < 0 (no real roots exist).
    
    Mathematical note:
        When D < 0, we would need to take the square root of a negative number,
        which results in complex/imaginary numbers. This function doesn't 
        calculate complex roots.
    
    Args:
        state: Current state with discriminant < 0
        
    Returns:
        Dictionary with message about no real roots
    """
    result = "No real roots"
    return {"result": result}

# Step 3: Define the Routing Function (Conditional Logic)

def check_condition(state: QuadState) -> str:
    """
    Determines which path to take based on discriminant value.
    
    This is the CORE of conditional workflow - it returns the NAME
    of the next function to execute.
    
    Args:
        state: Current state with calculated discriminant
        
    Returns:
        String name of the next function to execute:
        - "real_roots" if D > 0
        - "repeated_roots" if D = 0
        - "no_real_roots" if D < 0
        
    How it works:
        LangGraph will call this function, get the returned string,
        and automatically route to that node.
    """
    if state['discriminant'] > 0:
        return "real_roots"
    elif state['discriminant'] == 0:
        return "repeated_roots"
    else:
        return "no_real_roots"

# Step 4: Build the Graph

# Initialize the graph with our state type
graph = StateGraph(QuadState)

# Add all nodes to the graph
graph.add_node("show_equation", show_equation)
graph.add_node("calculate_discriminant", calculate_discriminant)
graph.add_node("real_roots", real_roots)
graph.add_node("repeated_roots", repeated_roots)
graph.add_node("no_real_roots", no_real_roots)

# Add regular edges (always execute)
graph.add_edge("__start__", "show_equation")
graph.add_edge("show_equation", "calculate_discriminant")

# Add CONDITIONAL edge - this is the key difference!
# Syntax: add_conditional_edges(source_node, routing_function)
graph.add_conditional_edges(
    "calculate_discriminant",  # After this node executes
    check_condition            # Call this function to decide next node
)

# All three possible paths converge to END
graph.add_edge("real_roots", "__end__")
graph.add_edge("repeated_roots", "__end__")
graph.add_edge("no_real_roots", "__end__")

# Compile the graph
workflow = graph.compile()

# Step 5: Execute the Workflow

# Example 1: Two real roots (D > 0)
initial_state = {
    "a": 4,
    "b": -5,
    "c": -4
}

result = workflow.invoke(initial_state)
print(result)
# Output:
# {
#     'a': 4, 'b': -5, 'c': -4,
#     'equation': '4xÂ² + -5x + -4',
#     'discriminant': 89.0,
#     'result': 'The roots are 1.976... and -0.476...'
# }

# Example 2: Repeated root (D = 0)
initial_state = {
    "a": 4,
    "b": -4,
    "c": 1
}

result = workflow.invoke(initial_state)
# Discriminant = 16 - 16 = 0
# Result: "Only repeating root is 0.5"

# Example 3: No real roots (D < 0)
initial_state = {
    "a": 2,
    "b": 2,
    "c": 4
}

result = workflow.invoke(initial_state)
# Discriminant = 4 - 32 = -28
# Result: "No real roots"
```

### ğŸ” Line-by-Line Breakdown of Key Concepts

#### Understanding `add_conditional_edges()`

```python
graph.add_conditional_edges(
    "calculate_discriminant",  # Source node
    check_condition            # Routing function
)
```

**What happens behind the scenes:**

1. **Execution reaches** `calculate_discriminant` node
2. **LangGraph automatically calls** `check_condition(state)`
3. **`check_condition` returns** a string (e.g., "real_roots")
4. **LangGraph routes** to the node with that name
5. **Only that node executes**, others are skipped

**Why this works:**
- The routing function must return the **exact name** of a node
- LangGraph uses this name to create the edge dynamically
- This is why edges appear "dotted" in visualizations - they're conditional

#### State Management Flow

```python
# Initial state
{"a": 4, "b": -5, "c": -4}

# After show_equation
{"a": 4, "b": -5, "c": -4, "equation": "4xÂ² + -5x + -4"}

# After calculate_discriminant
{"a": 4, "b": -5, "c": -4, "equation": "...", "discriminant": 89.0}

# After real_roots (since D > 0)
{"a": 4, "b": -5, "c": -4, "equation": "...", "discriminant": 89.0, 
 "result": "The roots are 1.976... and -0.476..."}
```

**Key principle:** Each node function returns a dictionary that **updates** the state, not replaces it.

---

## Example 2: Customer Support Review System (LLM-Based)

### ğŸ¯ Problem Statement
Build an intelligent customer support system that:
1. Analyzes customer review sentiment
2. Routes to different response strategies based on sentiment
3. For negative reviews, performs deeper diagnosis
4. Generates appropriate responses

### ğŸ—ºï¸ Workflow Design

```
Customer Review
    â†“
Analyze Sentiment (LLM)
    â†“
  (Check Sentiment)
    â”œâ”€â†’ [Positive] â†’ Generate Positive Response â†’ End
    â””â”€â†’ [Negative] â†’ Run Diagnosis (extract issue type, tone, urgency)
                         â†“
                    Generate Negative Response â†’ End
```

### Why This Approach?

**